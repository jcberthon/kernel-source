From: NeilBrown <neilb@suse.com>
Subject: Fix kABI for "Ensure we commit after writeback is complete"
Patch-mainline: Never, kabi
References: bsc#1111809

These two structures, nfs_pageio_descriptor and nfs_pgio_header, need
an extra field.

For nfs_pgio_header, the structure is always allocated by common code,
so it should be safe to just move it to the end of the structure.

For nfs_pageio_descriptor, the structure is allocated on the stack in:
  direct.c
  read.c
  write.c
  pnfs.c

As pnfs is in nfsv4.ko while the rest are in nfs.ko, this extra field
is a real part of the kABI. If some vendor module, such as an altered
version of nfsv4, allocated the structre on the stack, that would cause problems.

Fortunately nfs_pageio_descriptor() contains unused space.
Only one of pg_mirrors_static and pg_mirrors_dynamic is used at a time,
and we can tell which one by examining where pg_mirrors points.
So store the extra field in whichever space is currently unused.

Signed-off-by: NeilBrown <neilb@suse.com>


---
 fs/nfs/pagelist.c        |   12 ++++++++----
 fs/nfs/write.c           |    2 +-
 include/linux/nfs_page.h |   12 +++++++++++-
 include/linux/nfs_xdr.h  |    4 +++-
 4 files changed, 23 insertions(+), 7 deletions(-)

--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -64,7 +64,7 @@ void nfs_pgheader_init(struct nfs_pageio
 	hdr->cred = hdr->req->wb_context->cred;
 	hdr->io_start = req_offset(hdr->req);
 	hdr->good_bytes = mirror->pg_count;
-	hdr->io_completion = desc->pg_io_completion;
+	hdr->io_completion = *pg_io_completion(desc);
 	hdr->dreq = desc->pg_dreq;
 	hdr->layout_private = desc->pg_layout_private;
 	hdr->release = release;
@@ -734,7 +734,6 @@ void nfs_pageio_init(struct nfs_pageio_d
 	desc->pg_ioflags = io_flags;
 	desc->pg_error = 0;
 	desc->pg_lseg = NULL;
-	desc->pg_io_completion = NULL;
 	desc->pg_dreq = NULL;
 	desc->pg_layout_private = NULL;
 	desc->pg_bsize = bsize;
@@ -759,6 +758,7 @@ void nfs_pageio_init(struct nfs_pageio_d
 		desc->pg_mirrors = desc->pg_mirrors_static;
 		nfs_pageio_mirror_init(&desc->pg_mirrors[0], bsize);
 	}
+	*pg_io_completion(desc) = NULL;
 }
 EXPORT_SYMBOL_GPL(nfs_pageio_init);
 
@@ -884,7 +884,8 @@ static int nfs_pageio_setup_mirroring(st
 	if (!mirror_count || mirror_count > NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX)
 		return -EINVAL;
 
-	if (WARN_ON_ONCE(!pgio->pg_mirrors_dynamic))
+	if (WARN_ON_ONCE(!pgio->pg_mirrors_dynamic ||
+			 pgio->pg_mirrors != pgio->pg_mirrors_dynamic))
 		return -EINVAL;
 
 	pgio->pg_mirror_count = mirror_count;
@@ -903,11 +904,14 @@ void nfs_pageio_stop_mirroring(struct nf
 
 static void nfs_pageio_cleanup_mirroring(struct nfs_pageio_descriptor *pgio)
 {
+	struct nfs_io_completion *iocomp = *pg_io_completion(pgio);
+	*pg_io_completion(pgio) = NULL;
 	pgio->pg_mirror_count = 1;
 	pgio->pg_mirror_idx = 0;
 	pgio->pg_mirrors = pgio->pg_mirrors_static;
 	kfree(pgio->pg_mirrors_dynamic);
 	pgio->pg_mirrors_dynamic = NULL;
+	*pg_io_completion(pgio) = iocomp;
 }
 
 static bool nfs_match_open_context(const struct nfs_open_context *ctx1,
@@ -1228,7 +1232,7 @@ int nfs_pageio_resend(struct nfs_pageio_
 {
 	LIST_HEAD(failed);
 
-	desc->pg_io_completion = hdr->io_completion;
+	*pg_io_completion(desc) = hdr->io_completion;
 	desc->pg_dreq = hdr->dreq;
 	while (!list_empty(&hdr->pages)) {
 		struct nfs_page *req = nfs_list_entry(hdr->pages.next);
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -691,7 +691,7 @@ int nfs_writepages(struct address_space
 
 	nfs_pageio_init_write(&pgio, inode, wb_priority(wbc), false,
 				&nfs_async_write_completion_ops);
-	pgio.pg_io_completion = ioc;
+	*pg_io_completion(&pgio) = ioc;
 	err = write_cache_pages(mapping, wbc, nfs_writepages_callback, &pgio);
 	nfs_pageio_complete(&pgio);
 	nfs_io_completion_put(ioc);
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@ -94,7 +94,6 @@ struct nfs_pageio_descriptor {
 	const struct rpc_call_ops *pg_rpc_callops;
 	const struct nfs_pgio_completion_ops *pg_completion_ops;
 	struct pnfs_layout_segment *pg_lseg;
-	struct nfs_io_completion *pg_io_completion;
 	struct nfs_direct_req	*pg_dreq;
 	void			*pg_layout_private;
 	unsigned int		pg_bsize;	/* default bsize for mirrors */
@@ -106,6 +105,17 @@ struct nfs_pageio_descriptor {
 	u32			pg_mirror_idx;	/* current mirror */
 };
 
+static inline struct nfs_io_completion **pg_io_completion(struct nfs_pageio_descriptor *desc)
+{
+	static struct nfs_io_completion *failsafe = NULL;
+	if (desc->pg_mirrors == desc->pg_mirrors_static)
+		return (struct nfs_io_completion **)&desc->pg_mirrors_dynamic;
+	if (desc->pg_mirrors == desc->pg_mirrors_dynamic)
+		return (struct nfs_io_completion **)&desc->pg_mirrors_static[0].pg_list.next;
+	WARN_ON_ONCE(1);
+	return &failsafe;
+}
+
 /* arbitrarily selected limit to number of mirrors */
 #define NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX 16
 
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1391,7 +1391,6 @@ struct nfs_pgio_header {
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
 	const struct nfs_rw_ops	*rw_ops;
-	struct nfs_io_completion *io_completion;
 	struct nfs_direct_req	*dreq;
 	void			*layout_private;
 	spinlock_t		lock;
@@ -1415,6 +1414,9 @@ struct nfs_pgio_header {
 	struct nfs_client	*ds_clp;	/* pNFS data server */
 	int			ds_commit_idx;	/* ds index if ds_clp is set */
 	int			pgio_mirror_idx;/* mirror index in pgio layer */
+#ifndef __GENKSYMS__
+	struct nfs_io_completion *io_completion;
+#endif
 };
 
 struct nfs_mds_commit_info {
