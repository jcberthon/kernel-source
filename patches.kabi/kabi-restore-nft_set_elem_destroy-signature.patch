From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 13 Mar 2018 13:09:38 +0100
Subject: kabi: restore nft_set_elem_destroy() signature
Patch-mainline: Never, kabi workaround
References: bsc#1042286

Mainline commit 61f9e2924f49 ("netfilter: nf_tables: fix *leak* when expr
clone fail") adds argument destroy_expr to function nft_set_elem_destroy()
which is exported. Rename modified function and create a simple wrapper
passing true (which behaves as the original version) under the original
name.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/netfilter/nf_tables.h |    5 +++--
 net/netfilter/nf_tables_api.c     |   17 ++++++++++++-----
 net/netfilter/nft_dynset.c        |    2 +-
 net/netfilter/nft_hash.c          |    6 +++---
 net/netfilter/nft_rbtree.c        |    2 +-
 5 files changed, 20 insertions(+), 12 deletions(-)

--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -515,8 +515,9 @@ void *nft_set_elem_init(const struct nft
 			const struct nft_set_ext_tmpl *tmpl,
 			const u32 *key, const u32 *data,
 			u64 timeout, gfp_t gfp);
-void nft_set_elem_destroy(const struct nft_set *set, void *elem,
-			  bool destroy_expr);
+void nft_set_elem_destroy(const struct nft_set *set, void *elem);
+void nft_set_elem_destroy_ext(const struct nft_set *set, void *elem,
+			      bool destroy_expr);
 
 /**
  *	struct nft_set_gc_batch_head - nf_tables set garbage collection batch
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -3352,8 +3352,8 @@ void *nft_set_elem_init(const struct nft
 	return elem;
 }
 
-void nft_set_elem_destroy(const struct nft_set *set, void *elem,
-			  bool destroy_expr)
+void nft_set_elem_destroy_ext(const struct nft_set *set, void *elem,
+			      bool destroy_expr)
 {
 	struct nft_set_ext *ext = nft_set_elem_ext(set, elem);
 
@@ -3365,6 +3365,13 @@ void nft_set_elem_destroy(const struct n
 
 	kfree(elem);
 }
+EXPORT_SYMBOL_GPL(nft_set_elem_destroy_ext);
+
+/* kabi compatibility wrapper */
+void nft_set_elem_destroy(const struct nft_set *set, void *elem)
+{
+	return nft_set_elem_destroy_ext(set, elem, true);
+}
 EXPORT_SYMBOL_GPL(nft_set_elem_destroy);
 
 static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
@@ -3661,7 +3668,7 @@ void nft_set_gc_batch_release(struct rcu
 
 	gcb = container_of(rcu, struct nft_set_gc_batch, head.rcu);
 	for (i = 0; i < gcb->head.cnt; i++)
-		nft_set_elem_destroy(gcb->head.set, gcb->elems[i], true);
+		nft_set_elem_destroy(gcb->head.set, gcb->elems[i]);
 	kfree(gcb);
 }
 EXPORT_SYMBOL_GPL(nft_set_gc_batch_release);
@@ -3880,7 +3887,7 @@ static void nf_tables_commit_release(str
 		break;
 	case NFT_MSG_DELSETELEM:
 		nft_set_elem_destroy(nft_trans_elem_set(trans),
-				     nft_trans_elem(trans).priv, true);
+				     nft_trans_elem(trans).priv);
 		break;
 	}
 	kfree(trans);
@@ -4017,7 +4024,7 @@ static void nf_tables_abort_release(stru
 		break;
 	case NFT_MSG_NEWSETELEM:
 		nft_set_elem_destroy(nft_trans_elem_set(trans),
-				     nft_trans_elem(trans).priv, true);
+				     nft_trans_elem(trans).priv);
 		break;
 	}
 	kfree(trans);
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@ -54,7 +54,7 @@ static void *nft_dynset_new(struct nft_s
 	return elem;
 
 err2:
-	nft_set_elem_destroy(set, elem, false);
+	nft_set_elem_destroy_ext(set, elem, false);
 err1:
 	if (set->size)
 		atomic_dec(&set->nelems);
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@ -120,7 +120,7 @@ static bool nft_hash_update(struct nft_s
 
 	/* Another cpu may race to insert the element with the same key */
 	if (prev) {
-		nft_set_elem_destroy(set, he, true);
+		nft_set_elem_destroy(set, he);
 		he = prev;
 	}
 
@@ -129,7 +129,7 @@ out:
 	return true;
 
 err2:
-	nft_set_elem_destroy(set, he, true);
+	nft_set_elem_destroy(set, he);
 err1:
 	return false;
 }
@@ -331,7 +331,7 @@ static int nft_hash_init(const struct nf
 
 static void nft_hash_elem_destroy(void *ptr, void *arg)
 {
-	nft_set_elem_destroy((const struct nft_set *)arg, ptr, true);
+	nft_set_elem_destroy((const struct nft_set *)arg, ptr);
 }
 
 static void nft_hash_destroy(const struct nft_set *set)
--- a/net/netfilter/nft_rbtree.c
+++ b/net/netfilter/nft_rbtree.c
@@ -226,7 +226,7 @@ static void nft_rbtree_destroy(const str
 	while ((node = priv->root.rb_node) != NULL) {
 		rb_erase(node, &priv->root);
 		rbe = rb_entry(node, struct nft_rbtree_elem, node);
-		nft_set_elem_destroy(set, rbe, true);
+		nft_set_elem_destroy(set, rbe);
 	}
 }
 
