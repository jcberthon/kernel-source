From: Joerg Roedel <jroedel@suse.de>
Subject: Fix kABI breakage by KVM CVE fix
Patch-mainline: Never, kabi
References: bsc#1045922

The patch
  patches.kernel.org/4.4.100-004-KVM-x86-fix-singlestepping-over-syscall.patch
breaks kABI due to the introduction of tf to the emulation
context field.
This patch moves the new bool flag to the existing
regs_valid member to avoid the new member and preserve kabi.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/include/asm/kvm_emulate.h |    1 -
 arch/x86/include/asm/kvm_host.h    |    2 ++
 arch/x86/kvm/emulate.c             |    6 +++++-
 arch/x86/kvm/x86.c                 |   11 +++++++++--
 4 files changed, 16 insertions(+), 4 deletions(-)

--- a/arch/x86/include/asm/kvm_emulate.h
+++ b/arch/x86/include/asm/kvm_emulate.h
@@ -296,7 +296,6 @@ struct x86_emulate_ctxt {
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn't support insn */
-	bool tf;	/* TF value before instruction (after for syscall/sysret) */
 
 	bool have_exception;
 	struct x86_exception exception;
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -122,6 +122,8 @@ enum kvm_reg {
 	NR_VCPU_REGS
 };
 
+#define VCPU_REGS_TF	31 /* TF value before instruction (after for syscall/sysret) */
+
 enum kvm_reg_ex {
 	VCPU_EXREG_PDPTR = NR_VCPU_REGS,
 	VCPU_EXREG_CR3,
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2754,7 +2754,11 @@ static int em_syscall(struct x86_emulate
 		ctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);
 	}
 
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
+	if (ctxt->eflags & X86_EFLAGS_TF)
+		ctxt->regs_valid |= (1U << VCPU_REGS_TF);
+	else
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
+
 	return X86EMUL_CONTINUE;
 }
 
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5192,7 +5192,11 @@ static void init_emulate_ctxt(struct kvm
 	kvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);
 
 	ctxt->eflags = kvm_get_rflags(vcpu);
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
+	if (ctxt->eflags & X86_EFLAGS_TF)
+		ctxt->regs_valid |= (1U << VCPU_REGS_TF);
+	else
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
+
 
 	ctxt->eip = kvm_rip_read(vcpu);
 	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :
@@ -5592,12 +5596,15 @@ restart:
 
 	if (writeback) {
 		unsigned long rflags = kvm_x86_ops->get_rflags(vcpu);
+		bool tf = ((ctxt->regs_valid & (1U << VCPU_REGS_TF)) != 0);
+
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
 		toggle_interruptibility(vcpu, ctxt->interruptibility);
 		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;
 		if (vcpu->arch.hflags != ctxt->emul_flags)
 			kvm_set_hflags(vcpu, ctxt->emul_flags);
 		kvm_rip_write(vcpu, ctxt->eip);
-		if (r == EMULATE_DONE && ctxt->tf)
+ 		if (r == EMULATE_DONE && tf)
 			kvm_vcpu_do_singlestep(vcpu, &r);
 		if (!ctxt->have_exception ||
 		    exception_type(ctxt->exception.vector) == EXCPT_TRAP)
