From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 29 Nov 2018 15:47:02 +0100
Subject: Revert "media: v4l: event: Add subscription to list before calling
 "add" operation"
Patch-mainline: never, kabi
References: kabi

This reverts commit 4bda4fd0e3a238a79ba0750eb356940b68399017, upstream
commit 92539d3eda2c090b382699bbb896d4b54e9bdece. It fixes commit
ad608fbcf166fec809e402d548761768f602702c, but we reverted that from
SLE12-SP3 already. So this one does not apply.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/media/v4l2-core/v4l2-event.c | 43 ++++++++++++----------------
 1 file changed, 19 insertions(+), 24 deletions(-)

diff --git a/drivers/media/v4l2-core/v4l2-event.c b/drivers/media/v4l2-core/v4l2-event.c
index f5c8a952f0aa..b47ac4e053d0 100644
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -197,22 +197,6 @@ int v4l2_event_pending(struct v4l2_fh *fh)
 }
 EXPORT_SYMBOL_GPL(v4l2_event_pending);
 
-static void __v4l2_event_unsubscribe(struct v4l2_subscribed_event *sev)
-{
-	struct v4l2_fh *fh = sev->fh;
-	unsigned int i;
-
-	lockdep_assert_held(&fh->subscribe_lock);
-	assert_spin_locked(&fh->vdev->fh_lock);
-
-	/* Remove any pending events for this subscription */
-	for (i = 0; i < sev->in_use; i++) {
-		list_del(&sev->events[sev_pos(sev, i)].list);
-		fh->navailable--;
-	}
-	list_del(&sev->list);
-}
-
 int v4l2_event_subscribe(struct v4l2_fh *fh,
 			 const struct v4l2_event_subscription *sub, unsigned elems,
 			 const struct v4l2_subscribed_event_ops *ops)
@@ -244,23 +228,27 @@ int v4l2_event_subscribe(struct v4l2_fh *fh,
 
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
-	if (!found_ev)
-		list_add(&sev->list, &fh->subscribed);
 	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (found_ev) {
 		/* Already listening */
 		kfree(sev);
-	} else if (sev->ops && sev->ops->add) {
+		goto out_unlock;
+	}
+
+	if (sev->ops && sev->ops->add) {
 		ret = sev->ops->add(sev, elems);
 		if (ret) {
-			spin_lock_irqsave(&fh->vdev->fh_lock, flags);
-			__v4l2_event_unsubscribe(sev);
-			spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 			kfree(sev);
+			goto out_unlock;
 		}
 	}
 
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	list_add(&sev->list, &fh->subscribed);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+
+out_unlock:
 	mutex_unlock(&fh->subscribe_lock);
 
 	return ret;
@@ -295,6 +283,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 {
 	struct v4l2_subscribed_event *sev;
 	unsigned long flags;
+	int i;
 
 	if (sub->type == V4L2_EVENT_ALL) {
 		v4l2_event_unsubscribe_all(fh);
@@ -306,8 +295,14 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	sev = v4l2_event_subscribed(fh, sub->type, sub->id);
-	if (sev != NULL)
-		__v4l2_event_unsubscribe(sev);
+	if (sev != NULL) {
+		/* Remove any pending events for this subscription */
+		for (i = 0; i < sev->in_use; i++) {
+			list_del(&sev->events[sev_pos(sev, i)].list);
+			fh->navailable--;
+		}
+		list_del(&sev->list);
+	}
 
 	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
-- 
2.19.2

