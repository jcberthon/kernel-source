From: Borislav Petkov <bp@suse.de>
Date: Fri, 15 Dec 2017 19:56:13 +0100
Subject: xen/x86/entry: Use IBRS on entry to kernel space
Patch-mainline: Never, SUSE-Xen specific
References: bsc#1068032

Toggle IBRS on entry to kernel space: enable *after* CR3 write and
disable *before* CR3 write.

Originally-by: Tim Chen <tim.c.chen@linux.intel.com>
Signed-off-by: Borislav Petkov <bp@suse.de>
Automatically created from "patches.suse/03-x86-entry-use-ibrs-on-entry-to-kernel-space.patch" by xen-port-patches.py

--- a/arch/x86/ia32/ia32entry-xen.S
+++ b/arch/x86/ia32/ia32entry-xen.S
@@ -14,6 +14,7 @@
 #include <asm/segment.h>
 #include <asm/irqflags.h>
 #include <linux/linkage.h>
+#include <asm/spec_ctrl.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -135,6 +136,9 @@ ENTRY(ia32_sysenter_target)
 	movq	%r10,8(%rsp)
 	movq	%rax,(%rsp)
 	cld
+
+	ENABLE_IBRS
+
 	SAVE_ARGS 0,0,1
  	/* no need to do an access_ok check here because rbp has been
  	   32bit zero extended */ 
@@ -214,6 +218,9 @@ ENTRY(ia32_cstar_target)
 	movl	%ebp,%ecx
 	movl	$__USER32_CS,CS-ARGOFFSET(%rsp)
 	movl	$__USER32_DS,SS-ARGOFFSET(%rsp)
+
+	ENABLE_IBRS
+
 	/* no need to do an access_ok check here because r8 has been
 	   32bit zero extended */ 
 	/* hardware stack frame is complete now */	
@@ -307,6 +314,9 @@ ENTRY(ia32_syscall)
 	   this could be a problem. */
 	SAVE_ARGS 0,0,1
 	GET_THREAD_INFO(%r10)
+
+	ENABLE_IBRS
+
 	orl   $TS_COMPAT,TI_status(%r10)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	jnz ia32_tracesys
--- a/arch/x86/kernel/entry_64-xen.S
+++ b/arch/x86/kernel/entry_64-xen.S
@@ -57,9 +57,9 @@
 #include <asm/ftrace.h>
 #include <asm/percpu.h>
 #include <asm/pgtable_types.h>
-#include <asm/alternative-asm.h>
 #include <asm/cpufeature.h>
 #include <asm/kaiser.h>
+#include <asm/spec_ctrl.h>
 #include <xen/interface/xen.h>
 #include <xen/interface/features.h>
 
@@ -312,7 +312,7 @@ NMI_MASK = 0x80000000
 	testb $3,1*8(%rsp)
 	jnz   2f
 	testl $NMI_MASK,2*8(%rsp)
-	jnz   2f
+	jnz   3f
 
 	cmpb  $0,(xen_features+XENFEAT_supervisor_mode_kernel)(%rip)
 	jne   1f
@@ -324,7 +324,8 @@ NMI_MASK = 0x80000000
 	.endif
 
 2:	/* Slow iret via hypervisor. */
-	andl  $~NMI_MASK, 2*8(%rsp)
+	DISABLE_IBRS
+3:	andl  $~NMI_MASK, 2*8(%rsp)
 	pushq $\flag & VGCF_in_syscall
 	jmp  hypercall_page + (__HYPERVISOR_iret * 32)
 	.endm
@@ -358,6 +359,7 @@ ENTRY(save_args)
 	je 1f
 	SWAPGS
 	SWITCH_KERNEL_CR3
+	ENABLE_IBRS
 	/*
 	 * irq_count is used to check if a CPU is already on an interrupt stack
 	 * or not. While this is essentially redundant with preempt_count it is
@@ -449,6 +451,8 @@ ENTRY(save_paranoid)
 	movq	%rax, %cr3
 2:
 #endif
+
+	ENABLE_IBRS
 	ret
 	CFI_ENDPROC
 END(save_paranoid)
@@ -525,6 +529,9 @@ ENTRY(system_call)
 	SAVE_ARGS -8,1
 	movq  %rax,ORIG_RAX-ARGOFFSET(%rsp)
 	GET_THREAD_INFO(%rcx)
+
+	ENABLE_IBRS
+
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%rcx)
 	jnz tracesys
 system_call_fastpath:
@@ -556,6 +563,8 @@ sysret_check:
 	 */
 	TRACE_IRQS_ON
 	RESTORE_ARGS 1,8,0,0
+
+	DISABLE_IBRS
 	xor %ecx,%ecx
 	xor %r11,%r11
         HYPERVISOR_IRET VGCF_IN_SYSCALL
@@ -1188,6 +1197,9 @@ ENTRY(paranoid_exit)
 paranoid_kernel:
 	movq	%r12, %rbx		/* restore after paranoid_userspace */
 	TRACE_IRQS_IRETQ 0
+
+	DISABLE_IBRS
+
 #ifdef CONFIG_KAISER
 	/* No ALTERNATIVE for X86_FEATURE_KAISER: save_paranoid sets %ebx */
 	testl	$2, %ebx		/* SWITCH_USER_CR3 needed? */
@@ -1263,6 +1275,9 @@ ENTRY(error_entry)
 	 * the kernel CR3 here.
 	 */
 	SWITCH_KERNEL_CR3
+
+	ENABLE_IBRS
+
 	xorl %ebx,%ebx
 	testl $3,CS+8(%rsp)
 	je error_kernelspace
