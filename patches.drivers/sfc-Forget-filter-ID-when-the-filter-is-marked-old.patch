From: Andrew Rybchenko <Andrew.Rybchenko@oktetlabs.ru>
Date: Wed, 15 Jun 2016 17:44:20 +0100
Subject: sfc: Forget filter ID when the filter is marked old
Patch-mainline: v4.8-rc1
Git-commit: 6a37958b8aa57cf556935baf67b248e0d8baddbe
References: bsc#1017967 FATE#321663

It is required to remove setting of filter IDs to invalid from multicast
and unicast addresses caching functions.
Add initialization to invalid when filter table is created.
Add paranoid checks to track consistency.

Signed-off-by: Edward Cree <ecree@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/sfc/ef10.c |   53 ++++++++++++++++++++++++----------------
 1 file changed, 33 insertions(+), 20 deletions(-)

--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -3744,6 +3744,7 @@ static int efx_ef10_filter_table_probe(s
 	MCDI_DECLARE_BUF(outbuf, MC_CMD_GET_PARSER_DISP_INFO_OUT_LENMAX);
 	unsigned int pd_match_pri, pd_match_count;
 	struct efx_ef10_filter_table *table;
+	unsigned int i;
 	size_t outlen;
 	int rc;
 
@@ -3795,6 +3796,10 @@ static int efx_ef10_filter_table_probe(s
 		goto fail;
 	}
 
+	for (i = 0; i < ARRAY_SIZE(table->dev_uc_list); i++)
+		table->dev_uc_list[i].id = EFX_EF10_FILTER_ID_INVALID;
+	for (i = 0; i < ARRAY_SIZE(table->dev_mc_list); i++)
+		table->dev_mc_list[i].id = EFX_EF10_FILTER_ID_INVALID;
 	table->ucdef_id = EFX_EF10_FILTER_ID_INVALID;
 	table->bcast_id = EFX_EF10_FILTER_ID_INVALID;
 	table->mcdef_id = EFX_EF10_FILTER_ID_INVALID;
@@ -3909,19 +3914,26 @@ static void efx_ef10_filter_table_remove
 	kfree(table);
 }
 
-#define EFX_EF10_FILTER_DO_MARK_OLD(id) \
-	if (id != EFX_EF10_FILTER_ID_INVALID) { \
-		filter_idx = efx_ef10_filter_get_unsafe_id(efx, id); \
-		if (!table->entry[filter_idx].spec) \
-			netif_dbg(efx, drv, efx->net_dev, \
-				  "%s: marked null spec old %04x:%04x\n", \
-				  __func__, id, filter_idx); \
-		table->entry[filter_idx].spec |= EFX_EF10_FILTER_FLAG_AUTO_OLD;\
+static void efx_ef10_filter_mark_one_old(struct efx_nic *efx, uint16_t *id)
+{
+	struct efx_ef10_filter_table *table = efx->filter_state;
+	unsigned int filter_idx;
+
+	if (*id != EFX_EF10_FILTER_ID_INVALID) {
+		filter_idx = efx_ef10_filter_get_unsafe_id(efx, *id);
+		if (!table->entry[filter_idx].spec)
+			netif_dbg(efx, drv, efx->net_dev,
+				  "marked null spec old %04x:%04x\n", *id,
+				  filter_idx);
+		table->entry[filter_idx].spec |= EFX_EF10_FILTER_FLAG_AUTO_OLD;
+		*id = EFX_EF10_FILTER_ID_INVALID;
 	}
+}
+
 static void efx_ef10_filter_mark_old(struct efx_nic *efx)
 {
 	struct efx_ef10_filter_table *table = efx->filter_state;
-	unsigned int filter_idx, i;
+	unsigned int i;
 
 	if (!table)
 		return;
@@ -3929,15 +3941,14 @@ static void efx_ef10_filter_mark_old(str
 	/* Mark old filters that may need to be removed */
 	spin_lock_bh(&efx->filter_lock);
 	for (i = 0; i < table->dev_uc_count; i++)
-		EFX_EF10_FILTER_DO_MARK_OLD(table->dev_uc_list[i].id);
+		efx_ef10_filter_mark_one_old(efx, &table->dev_uc_list[i].id);
 	for (i = 0; i < table->dev_mc_count; i++)
-		EFX_EF10_FILTER_DO_MARK_OLD(table->dev_mc_list[i].id);
-	EFX_EF10_FILTER_DO_MARK_OLD(table->ucdef_id);
-	EFX_EF10_FILTER_DO_MARK_OLD(table->bcast_id);
-	EFX_EF10_FILTER_DO_MARK_OLD(table->mcdef_id);
+		efx_ef10_filter_mark_one_old(efx, &table->dev_mc_list[i].id);
+	efx_ef10_filter_mark_one_old(efx, &table->ucdef_id);
+	efx_ef10_filter_mark_one_old(efx, &table->bcast_id);
+	efx_ef10_filter_mark_one_old(efx, &table->mcdef_id);
 	spin_unlock_bh(&efx->filter_lock);
 }
-#undef EFX_EF10_FILTER_DO_MARK_OLD
 
 static void efx_ef10_filter_uc_addr_list(struct efx_nic *efx, bool *promisc)
 {
@@ -3947,7 +3958,6 @@ static void efx_ef10_filter_uc_addr_list
 	int addr_count;
 	unsigned int i;
 
-	table->ucdef_id = EFX_EF10_FILTER_ID_INVALID;
 	addr_count = netdev_uc_count(net_dev);
 	if (net_dev->flags & IFF_PROMISC)
 		*promisc = true;
@@ -3960,7 +3970,6 @@ static void efx_ef10_filter_uc_addr_list
 			break;
 		}
 		ether_addr_copy(table->dev_uc_list[i].addr, uc->addr);
-		table->dev_uc_list[i].id = EFX_EF10_FILTER_ID_INVALID;
 		i++;
 	}
 }
@@ -3972,8 +3981,6 @@ static void efx_ef10_filter_mc_addr_list
 	struct netdev_hw_addr *mc;
 	unsigned int i, addr_count;
 
-	table->mcdef_id = EFX_EF10_FILTER_ID_INVALID;
-	table->bcast_id = EFX_EF10_FILTER_ID_INVALID;
 	if (net_dev->flags & (IFF_PROMISC | IFF_ALLMULTI))
 		*promisc = true;
 
@@ -3985,7 +3992,6 @@ static void efx_ef10_filter_mc_addr_list
 			break;
 		}
 		ether_addr_copy(table->dev_mc_list[i].addr, mc->addr);
-		table->dev_mc_list[i].id = EFX_EF10_FILTER_ID_INVALID;
 		i++;
 	}
 
@@ -4063,6 +4069,8 @@ static int efx_ef10_filter_insert_addr_l
 			}
 			return rc;
 		} else {
+			EFX_WARN_ON_PARANOID(table->bcast_id !=
+					     EFX_EF10_FILTER_ID_INVALID);
 			table->bcast_id = efx_ef10_filter_get_unsafe_id(efx, rc);
 		}
 	}
@@ -4096,6 +4104,8 @@ static int efx_ef10_filter_insert_def(st
 			     "%scast mismatch filter insert failed rc=%d\n",
 			     multicast ? "Multi" : "Uni", rc);
 	} else if (multicast) {
+		EFX_WARN_ON_PARANOID(table->mcdef_id !=
+				     EFX_EF10_FILTER_ID_INVALID);
 		table->mcdef_id = efx_ef10_filter_get_unsafe_id(efx, rc);
 		if (!nic_data->workaround_26807) {
 			/* Also need an Ethernet broadcast filter */
@@ -4118,11 +4128,14 @@ static int efx_ef10_filter_insert_def(st
 					return rc;
 				}
 			} else {
+				EFX_WARN_ON_PARANOID(table->bcast_id !=
+						     EFX_EF10_FILTER_ID_INVALID);
 				table->bcast_id = efx_ef10_filter_get_unsafe_id(efx, rc);
 			}
 		}
 		rc = 0;
 	} else {
+		EFX_WARN_ON_PARANOID(table->ucdef_id != EFX_EF10_FILTER_ID_INVALID);
 		table->ucdef_id = rc;
 		rc = 0;
 	}
