From: Mitch Williams <mitch.a.williams@intel.com>
Date: Tue, 29 Aug 2017 05:32:30 -0400
Subject: i40e: add private flag to control source pruning
Patch-mainline: v4.15-rc1
Git-commit: 64615b5418bac1d3b3a50a83fb2e42091fe299fe
References: bsc#1034075

By default, our devices do source pruning, that is, they drop receive
packets that have the source MAC matching one of the receive filters.
Unfortunately, this breaks ARP monitoring in channel bonding, as the
bonding driver expects devices to receive ARPs containing their own
source address.

Add an ethtool private flag to control this feature.

Also, remove the netif_running() check when we process our private
flags. It's OK to reset when the device is closed and in most cases we
need the reset the apply these changes.

Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Michal Kubecek <mkubecek@suse.cz>

---
 drivers/net/ethernet/intel/i40e/i40e.h         |    2 ++
 drivers/net/ethernet/intel/i40e/i40e_ethtool.c |   13 +++++++++++++
 drivers/net/ethernet/intel/i40e/i40e_main.c    |   25 +++++++++++++++++++++++++
 3 files changed, 40 insertions(+)

--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -104,6 +104,7 @@
 #define I40E_PRIV_FLAGS_VEB_STATS	BIT(3)
 #define I40E_PRIV_FLAGS_PS		BIT(4)
 #define I40E_PRIV_FLAGS_HW_ATR_EVICT	BIT(5)
+#define I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED	BIT(6)
 
 #define I40E_NVM_VERSION_LO_SHIFT  0
 #define I40E_NVM_VERSION_LO_MASK   (0xff << I40E_NVM_VERSION_LO_SHIFT)
@@ -364,6 +365,7 @@ struct i40e_pf {
 #define I40E_FLAG_STOP_FW_LLDP			BIT_ULL(47)
 #define I40E_FLAG_HAVE_10GBASET_PHY		BIT_ULL(48)
 #define I40E_FLAG_PF_MAC			BIT_ULL(50)
+#define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(59)
 
 	/* tracks features that get auto disabled by errors */
 	u64 auto_disable_flags;
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -235,6 +235,7 @@ static const char i40e_priv_flags_string
 	"veb-stats",
 	"packet-split",
 	"hw-atr-eviction",
+	"disable-source-pruning",
 };
 
 #define I40E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_priv_flags_strings)
@@ -2797,6 +2798,8 @@ static u32 i40e_get_priv_flags(struct ne
 		I40E_PRIV_FLAGS_PS : 0;
 	ret_flags |= pf->auto_disable_flags & I40E_FLAG_HW_ATR_EVICT_CAPABLE ?
 		0 : I40E_PRIV_FLAGS_HW_ATR_EVICT;
+	ret_flags |= pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED ?
+		I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED : 0;
 
 	return ret_flags;
 }
@@ -2864,6 +2867,16 @@ static int i40e_set_priv_flags(struct ne
 	else
 		pf->auto_disable_flags |= I40E_FLAG_HW_ATR_EVICT_CAPABLE;
 
+	if ((flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+	    !(pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags |= I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	} else if (!(flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+		   (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags &= ~I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	}
+
 	/* if needed, issue reset to cause things to take effect */
 	if (reset_required)
 		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED));
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -9485,6 +9485,31 @@ static int i40e_add_vsi(struct i40e_vsi
 
 		enabled_tc = i40e_pf_get_tc_map(pf);
 
+		/* Source pruning is enabled by default, so the flag is
+		 * negative logic - if it's set, we need to fiddle with
+		 * the VSI to disable source pruning.
+		 */
+		if (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED) {
+			memset(&ctxt, 0, sizeof(ctxt));
+			ctxt.seid = pf->main_vsi_seid;
+			ctxt.pf_num = pf->hw.pf_id;
+			ctxt.vf_num = 0;
+			ctxt.info.valid_sections |=
+			     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);
+			ctxt.info.switch_id =
+				   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_LOCAL_LB);
+			ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
+			if (ret) {
+				dev_info(&pf->pdev->dev,
+					 "update vsi failed, err %s aq_err %s\n",
+					 i40e_stat_str(&pf->hw, ret),
+					 i40e_aq_str(&pf->hw,
+						    pf->hw.aq.asq_last_status));
+				ret = -ENOENT;
+				goto err;
+			}
+		}
+
 		/* MFP mode setup queue map and update VSI */
 		if ((pf->flags & I40E_FLAG_MFP_ENABLED) &&
 		    !(pf->hw.func_caps.iscsi)) { /* NIC type PF */
