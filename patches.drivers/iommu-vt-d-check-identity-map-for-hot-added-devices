From: Lu Baolu <baolu.lu@linux.intel.com>
Date: Mon, 25 Feb 2019 10:46:36 +0800
Subject: iommu/vt-d: Check identity map for hot-added devices
Git-commit: 117266fd59ddf46e98e36df09326d861738c6180
Patch-mainline: v5.1-rc1
References: bsc#1129248

The Intel IOMMU driver will put devices into a static identity
mapped domain during boot if the kernel parameter "iommu=pt" is
used. That means the IOMMU hardware will translate a DMA address
into the same memory address.

Unfortunately, hot-added devices are not subject to this. That
results in some devices not working properly after hot added. A
quick way to reproduce this issue is to boot a system with

    iommu=pt

and, remove then readd the pci device with

    echo 1 > /sys/bus/pci/devices/[pci_source_id]/remove
    echo 1 > /sys/bus/pci/rescan

You will find the identity mapped domain was replaced with a
normal domain.

Cc: Ashok Raj <ashok.raj@intel.com>
Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
Cc: Fenghua Yu <fenghua.yu@intel.com>
Cc: stable@vger.kernel.org
Reported-by: Jis Ben <jisben@google.com>
Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Tested-by: James Dong <xmdong@google.com>
Fixes: 99dcadede42f ('intel-iommu: Support PCIe hot-plug')
Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 drivers/iommu/intel-iommu.c | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

--- a/drivers/pci/intel-iommu.c
+++ b/drivers/pci/intel-iommu.c
@@ -3577,22 +3577,25 @@ static int device_notifier(struct notifi
 	if (iommu_no_mapping(dev))
 		return 0;
 
-	if (action != BUS_NOTIFY_REMOVED_DEVICE)
-		return 0;
-
-	domain = find_domain(pdev);
-	if (!domain)
-		return 0;
+	if (action == BUS_NOTIFY_REMOVED_DEVICE) {
+		domain = find_domain(pdev);
+		if (!domain)
+			return 0;
 
-	if (!iommu_pass_through) {
-		domain_remove_one_dev_info(domain, pdev);
+		if (!iommu_pass_through) {
+			domain_remove_one_dev_info(domain, pdev);
 
-		if (!(domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE) &&
-		    !(domain->flags & DOMAIN_FLAG_STATIC_IDENTITY) &&
-		    list_empty(&domain->devices))
-			domain_exit(domain);
+			if (!(domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE) &&
+			    !(domain->flags & DOMAIN_FLAG_STATIC_IDENTITY) &&
+			    list_empty(&domain->devices))
+				domain_exit(domain);
+		}
+	} else if (action == BUS_NOTIFY_ADD_DEVICE) {
+		if (iommu_should_identity_map(pdev, 1))
+			domain_add_dev_info(si_domain, pdev, hw_pass_through ? CONTEXT_TT_PASS_THROUGH : CONTEXT_TT_MULTI_LEVEL);
 	}
 
+
 	return 0;
 }
 

