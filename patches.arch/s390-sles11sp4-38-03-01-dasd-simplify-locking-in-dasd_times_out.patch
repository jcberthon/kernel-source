From: Sebastian Ott <sebott@linux.ibm.com>
Subject: dasd: fix deadlock in dasd_times_out
Git-commit: 1bcdb5354aee2c0abcd13d912be35ae39a4144b6
Patch-mainline: v4.18-rc1
References: bnc#1117943, LTC#174111

Description:  dasd: fix deadlock in dasd_times_out
Symptom:      System does not respond after disk timeout.
Problem:      The dasd_times_out function processes requests that have an
              internal timeout as well as an external timeout called through
              dasd_ioctl_abortio().
              For the latter type of requests the CQR may be already in a final
              state. The if-else path in dasd_times_out does not handle CQRs in
              the final states DASD_CQR_DONE, DASD_CQR_FAILED and
              DASD_CQR_TERMINATED and therefore the ccw device lock is never
              freed.
Solution:     Provide __dasd_cancel_req that is called with the ccw device lock
              held to simplify the locking in dasd_times_out and fix the
              deadlock issue. Also ensure that interrupts are disabled. The
              function may get called with interrupts enabled or already
              disabled.
Reproduction: Run IO on disks that do not respond to IO requests in a given
              amount of time for example due to hardware failure or reserved
              disk state.

Upstream-Description:

              s390/dasd: simplify locking in dasd_times_out

              Provide __dasd_cancel_req that is called with the ccw device lock
              held to simplify the locking in dasd_times_out. Also this removes
              the following sparse warning:
              context imbalance in 'dasd_times_out' - different lock contexts for basic block

              Note: with this change dasd_schedule_device_bh is now called (via
              dasd_cancel_req) with the ccw device lock held. But is is already
              the case for other codepaths.

              Signed-off-by: Sebastian Ott <sebott@linux.ibm.com>
              Reviewed-by: Stefan Haberland <sth@linux.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---

---
 drivers/s390/block/dasd.c |   30 +++++++++++++++++-------------
 1 file changed, 17 insertions(+), 13 deletions(-)

--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -2358,14 +2358,11 @@ int dasd_sleep_on_immediatly(struct dasd
  * Cancellation of a request is an asynchronous operation! The calling
  * function has to wait until the request is properly returned via callback.
  */
-int dasd_cancel_req(struct dasd_ccw_req *cqr)
+static int __dasd_cancel_req(struct dasd_ccw_req *cqr)
 {
 	struct dasd_device *device = cqr->startdev;
-	unsigned long flags;
-	int rc;
+	int rc = 0;
 
-	rc = 0;
-	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
 	switch (cqr->status) {
 	case DASD_CQR_QUEUED:
 		/* request was not started - just set to cleared */
@@ -2385,11 +2382,22 @@ int dasd_cancel_req(struct dasd_ccw_req
 	default: /* already finished or clear pending - do nothing */
 		break;
 	}
-	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
 	dasd_schedule_device_bh(device);
 	return rc;
 }
 
+int dasd_cancel_req(struct dasd_ccw_req *cqr)
+{
+	struct dasd_device *device = cqr->startdev;
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
+	rc = __dasd_cancel_req(cqr);
+	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
+	return rc;
+}
+
 /*
  * SECTION: Operations of the dasd_block layer.
  */
@@ -2877,12 +2885,10 @@ enum blk_eh_timer_return dasd_times_out(
 	cqr->retries = -1;
 	cqr->intrc = -ETIMEDOUT;
 	if (cqr->status >= DASD_CQR_QUEUED) {
-		spin_unlock(get_ccwdev_lock(device->cdev));
-		rc = dasd_cancel_req(cqr);
+		rc = __dasd_cancel_req(cqr);
 	} else if (cqr->status == DASD_CQR_FILLED ||
 		   cqr->status == DASD_CQR_NEED_ERP) {
 		cqr->status = DASD_CQR_TERMINATED;
-		spin_unlock(get_ccwdev_lock(device->cdev));
 	} else if (cqr->status == DASD_CQR_IN_ERP) {
 		struct dasd_ccw_req *searchcqr, *nextcqr, *tmpcqr;
 
@@ -2897,9 +2903,7 @@ enum blk_eh_timer_return dasd_times_out(
 			searchcqr->retries = -1;
 			searchcqr->intrc = -ETIMEDOUT;
 			if (searchcqr->status >= DASD_CQR_QUEUED) {
-				spin_unlock(get_ccwdev_lock(device->cdev));
-				rc = dasd_cancel_req(searchcqr);
-				spin_lock(get_ccwdev_lock(device->cdev));
+				rc = __dasd_cancel_req(searchcqr);
 			} else if ((searchcqr->status == DASD_CQR_FILLED) ||
 				   (searchcqr->status == DASD_CQR_NEED_ERP)) {
 				searchcqr->status = DASD_CQR_TERMINATED;
@@ -2913,9 +2917,9 @@ enum blk_eh_timer_return dasd_times_out(
 			}
 			break;
 		}
-		spin_unlock(get_ccwdev_lock(device->cdev));
 	}
 	dasd_schedule_block_bh(block);
+	spin_unlock(get_ccwdev_lock(device->cdev));
 	spin_unlock(&block->queue_lock);
 
 	return rc ? BLK_EH_RESET_TIMER : BLK_EH_NOT_HANDLED;
