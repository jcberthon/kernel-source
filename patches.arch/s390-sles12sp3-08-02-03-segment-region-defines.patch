From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL
Patch-mainline: v4.8-rc1
Git-commit: 2dffdcbac91c8da1eb0663d6eab92f2e5b56a798
References: FATE#324087, LTC#158827

Summary:     kernel: instruction execution protection
Description: Instruction execution protection is designed to enhance
             reliability and security. It prevents the execution of
             instructions in virtual memory locations that are not
             intended to contain instructions. 

Upstream-Description:

             s390/vmem: introduce and use SEGMENT_KERNEL and REGION3_KERNEL

             Instead of open-coded SEGMENT_KERNEL and REGION3_KERNEL assignments use
             defines.  Also to make e.g. pmd_wrprotect() work on the kernel mapping
             a couple more flags must be set. Therefore add the missing flags also.

             In order to make everything symmetrical this patch also adds software
             dirty, young, read and write bits for region 3 table entries.

             Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
             Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
             Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/include/asm/pgtable.h |   33 ++++++++++++++++++++++++++++++++-
 arch/s390/mm/vmem.c             |   13 +++++--------
 2 files changed, 37 insertions(+), 9 deletions(-)

--- a/arch/s390/include/asm/pgtable.h
+++ b/arch/s390/include/asm/pgtable.h
@@ -273,8 +273,12 @@ static inline int is_module_addr(void *a
 #define _REGION3_ENTRY		(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_LENGTH)
 #define _REGION3_ENTRY_EMPTY	(_REGION_ENTRY_TYPE_R3 | _REGION_ENTRY_INVALID)
 
-#define _REGION3_ENTRY_LARGE	0x400	/* RTTE-format control, large page  */
 #define _REGION3_ENTRY_RO	0x200	/* page protection bit		    */
+#define _REGION3_ENTRY_DIRTY	0x2000	/* SW region dirty bit */
+#define _REGION3_ENTRY_YOUNG	0x1000	/* SW region young bit */
+#define _REGION3_ENTRY_LARGE	0x0400	/* RTTE-format control, large page  */
+#define _REGION3_ENTRY_READ	0x0002	/* SW region read bit */
+#define _REGION3_ENTRY_WRITE	0x0001	/* SW region write bit */
 
 /* Bits in the segment table entry */
 #define _SEGMENT_ENTRY_BITS	0xfffffffffffffe33UL
@@ -413,6 +417,33 @@ static inline void csp(unsigned int *ptr
 				 _SEGMENT_ENTRY_READ)
 #define SEGMENT_WRITE	__pgprot(_SEGMENT_ENTRY_READ | \
 				 _SEGMENT_ENTRY_WRITE)
+#define SEGMENT_KERNEL	__pgprot(_SEGMENT_ENTRY |	\
+				 _SEGMENT_ENTRY_LARGE |	\
+				 _SEGMENT_ENTRY_READ |	\
+				 _SEGMENT_ENTRY_WRITE | \
+				 _SEGMENT_ENTRY_YOUNG | \
+				 _SEGMENT_ENTRY_DIRTY)
+#define SEGMENT_KERNEL_RO __pgprot(_SEGMENT_ENTRY |	\
+				 _SEGMENT_ENTRY_LARGE |	\
+				 _SEGMENT_ENTRY_READ |	\
+				 _SEGMENT_ENTRY_YOUNG |	\
+				 _SEGMENT_ENTRY_PROTECT)
+
+/*
+ * Region3 entry (large page) protection definitions.
+ */
+
+#define REGION3_KERNEL	__pgprot(_REGION_ENTRY_TYPE_R3 | \
+				 _REGION3_ENTRY_LARGE |	 \
+				 _REGION3_ENTRY_READ |	 \
+				 _REGION3_ENTRY_WRITE |	 \
+				 _REGION3_ENTRY_YOUNG |	 \
+				 _REGION3_ENTRY_DIRTY)
+#define REGION3_KERNEL_RO __pgprot(_REGION_ENTRY_TYPE_R3 | \
+				   _REGION3_ENTRY_LARGE |  \
+				   _REGION3_ENTRY_READ |   \
+				   _REGION3_ENTRY_YOUNG |  \
+				   _REGION_ENTRY_PROTECT)
 
 static inline int mm_has_pgste(struct mm_struct *mm)
 {
--- a/arch/s390/mm/vmem.c
+++ b/arch/s390/mm/vmem.c
@@ -99,9 +99,8 @@ static int vmem_add_mem(unsigned long st
 #ifndef CONFIG_DEBUG_PAGEALLOC
 		if (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&
 		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end)) {
-			pud_val(*pu_dir) = __pa(address) |
-				_REGION_ENTRY_TYPE_R3 | _REGION3_ENTRY_LARGE |
-				(ro ? _REGION_ENTRY_PROTECT : 0);
+			pud_val(*pu_dir) = address |
+				pgprot_val(ro ? REGION3_KERNEL_RO : REGION3_KERNEL);
 			address += PUD_SIZE;
 			continue;
 		}
@@ -116,10 +115,8 @@ static int vmem_add_mem(unsigned long st
 #ifndef CONFIG_DEBUG_PAGEALLOC
 		if (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&
 		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end)) {
-			pmd_val(*pm_dir) = __pa(address) |
-				_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE |
-				_SEGMENT_ENTRY_YOUNG |
-				(ro ? _SEGMENT_ENTRY_PROTECT : 0);
+			pmd_val(*pm_dir) = address |
+				pgprot_val(ro ? SEGMENT_KERNEL_RO : SEGMENT_KERNEL);
 			address += PMD_SIZE;
 			continue;
 		}
@@ -132,7 +129,7 @@ static int vmem_add_mem(unsigned long st
 		}
 
 		pt_dir = pte_offset_kernel(pm_dir, address);
-		pte_val(*pt_dir) = __pa(address) |
+		pte_val(*pt_dir) = address |
 			pgprot_val(ro ? PAGE_KERNEL_RO : PAGE_KERNEL);
 		address += PAGE_SIZE;
 	}
